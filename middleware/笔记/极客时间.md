```
是否限流
可以限流:保守策略,下游是否会被冲垮
可以不限:下游很强,业务要求可用性很高尽量容错策略
限流算法: 令牌桶 ,漏桶,固定窗口,滑动窗口
```


```
io.readcloser 读完就没有了
而request.body就是这个
```


```
uuid
uuid 技术手段,guid业务概念

雪花算法 12比特的自增序列每秒能存储4096自增id,问题,如果需要超过这个呢,答:一秒4096就相当于4096次io机器也没法达到
```



```
短信服务

短信重试机制
收到发送短信的请求,立刻存储到数据库
立刻尝试发送
发送失败,异步发送
如果遇到超时,右异步发送了,可以使用去重方法,具体:在数据库建立唯一索引并携带biz_type和biz_id  索引冲突就取消发送


短信面试第二十六讲5分组
sms作业 service->sms->async包
大部分业务不需要分布式事务,只需要重试就行,只有金融相关需要

```




```
并发
查询做某事 都要考虑并发问题
```

```
分布式
分布式系统,常见电商业务里边,强数据一致性基本不可能的事情,因为数据一致性源于两个根源1,并发读写,2,部分失败如更新db成功,缓存失败,加锁只能解决并发更新的不一致,但是部分失败解决不了,部分失败需要分布式事务解决

```

```
基础
不能使用 str/3 来计算长度,因为有些扩展字符集是4,如表情包

var du *ss 也是分配了一个内存,但是只能放指针,又没有给指针赋值,说明指针指向哪里,所以是nil

自引用,要在编译时确定内存,所有直接 node是不行的,需要*node

如果一个channel 需要传来传去,最好与一个结构体绑定,由结构体来操作
goroutine泄露通常伴随着内存泄露,如何查看goroutine泄露 runtime.numgoroutine可以查看数量,业务的goroutine数量通常很稳定,如果持续上升就说明泄露了
```

```
可观测性
99线 指定一个业务99%的业务都在1秒内,99线就是1秒,如果99.9的请求在2秒内.999线就是2秒
otel
trace.spanfromcontext 复用span
```
```
http怎么建起来的:


gorm为什么ctx要往下传: gorm会传到sqldb -> sql driver -> 驱动的实现在跟数据库打交到的时候会监听ctx,如果ctx被调用cancel 或 超时 就会返回 
ctx会一路往下传递,传到db的 conn 会先判断超时没有,再去拿连接池的连接,紧接在判断超时没有, 紧接着进入driver
```

```
ranking 的 startTime是为了确保排序的稳定性,如果在排序的时候第一批成功,执行第二批的时候第一批修改了排序就会不稳定,在所有批次
执行前由一个startTime确保排序的稳定性
```


```
如果一个接口只需要实现一个方法,我们又需要使用 就可以将方法定义为一个类型
再去实现方法如:
type DoSomething interface {
	DoABC() string
}

type DoSomethingFunc func() string

func (d DoSomethingFunc) DoABC() string {
	return d()
}
```