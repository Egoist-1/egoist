upsert
insert on conflict() do nothing
insert on conflict() do updates ccc where
mysql只有一种写法 insert xxx on duplicate key updat xxx

事务传播机制 依赖于threadlocal机制线程本地存储 ,go事务无法绑定与goroutinu,
goroutinu本身是不可操作的实体

短信面试第二十六讲5分组
sms作业 service->sms->async包
大部分业务不需要分布式事务,只需要重试就行,只有金融相关需要

不能使用 str/3 来计算长度,因为有些扩展字符集是4,如表情包

var du *ss 也是分配了一个内存,但是只能放指针,又没有给指针赋值,说明指针指向哪里,所以是nil

自引用,要在编译时确定内存,所有直接 node是不行的,需要*node

uuid 技术手段,guid业务概念

雪花算法 12比特的自增序列每秒能存储4096自增id,问题,如果需要超过这个呢,答:一秒4096就相当于4096次io机器也没法达到

在设计order by语句的时候,要注意让order by命中索引
查询时只会用一个索引,那么这个索引最好包含order的列
如:where id  order by ctime utime  >==  联合 index id ct ut

怎么设计联合索引:where查询条件,最左原则,排序 范围 区分度esr

查询做某事 都要考虑并发问题

预加载缓存方案 : 例如缓存了一页list文章摘要,猜测只有第一条时常被访问的,就缓存第一条的全部内容
缓存方案:一个贴子发送的时候立即缓存,认为一个新的贴子会有很多人访问

分布式系统,常见电商业务里边,强数据一致性基本不可能的事情,因为数据一致性源于两个根源1,并发读写,2,部分失败如更新db成功,缓存失败,加锁只能解决并发更新的不一致,但是部分失败解决不了,部分失败需要分布式事务解决

kafka分区设计多少,要根据生产者速率,消费者速率,消息体多长 算法:要知道每一个分区的qps能撑多少,max(发送者总速率/单一分区写入速率,发送这总速率/单一消费者速率) + buffer
,正常情况下同一个topic的分区会尽量均匀分散到所有broker上,意味着:第一主分区之间.不会在同一个broker上,第二:同一个分区的主分区和从分区,也不会在同一个broker上,如果要保证消息的有序,就要保证消息发送到同一个分区,消息重复消费可能源自,生产者重复发送或者消费者消费成功但是没有提交

如果一个channel 需要传来传去,最好与一个结构体绑定,由结构体来操作
goroutine泄露通常伴随着内存泄露,如何查看goroutine泄露 runtime.numgoroutine可以查看数量,业务的goroutine数量通常很稳定,如果持续上升就说明泄露了

dckr_pat_YtyqPC_wIFDXqYqebsPQDe-tMow