```
k8s
pod
	一个pod 就是一个实例,一个pod可以跑很多容器
service
	将一组pod封装成一个服务,并且提供统一的入口访问这个服务,只有deployment是无法从外面访问的,需要将pod 封装为一个逻辑上的服务,即service
deployment
	管理pod的组件
PersistentVolume(持久化卷)pv
	:告诉pvc自己需要什么类型,如果没有匹配就会报错
pvc
	:设置自己都有什么类型的,供pv选择
ingress:
	代表路由规则,分发到不用的service
ingressController
	ingress 时你的配置.ingressController时执行这些配置的
	
```

```
缓存
要考虑的命中率如登录是低频的就没必要缓存,或者在创建时缓存,因为创建之后通常就要进行其他操作把,直接就能命中缓存
```

```
测试:
mock
sqlmock go get github.com/DATA-DOG/go-sqlmock
```

```
是否限流
可以限流:保守策略,下游是否会被冲垮
可以不限:下游很强,业务要求可用性很高尽量容错策略
限流算法: 令牌桶 ,漏桶,固定窗口,滑动窗口
```

```
使用redis的zset命令实现滑动窗口
假设窗口时 1分钟 限流是n 使用时间戳作为score 
来了一个请求 此时时间戳是t1
看看zset score(t1-1m,t1)之内有多少请求
如果 <n 就放行
否则 拒绝
```

```
装饰器
开闭原则:对修改代码闭合,意思就是 不要去修改原有的代码,对扩展开放,
非侵入式;不修改已有代码
```

```
单方法的接口 
type DoSomething interface{
	DoABC() string
}
type DoSomething func() string
func(d DoSomething) DoABC() string{
	return d
}
```

```
为什么要使用长短token
效率和安全的折中
因为短token 频繁的被使用 容易泄露
所以要是短token过期了,直接生成一个新token就和刷新区别不大了
因此只有长token调用refresh时 才会生成新的短token
提问:长token泄露了
	回答:长短token同时刷新
		或者可以在长token里加入user-agent其他校验是否时本人
长短tokne同时刷新存在一个问题,调用refresh时超时了,这时老的refresh已经没用了所以用户只能重新登录
```

```
io.readcloser 读完就没有了
而request.body就是这个
```

```
短信重试机制
收到发送短信的请求,立刻存储到数据库
立刻尝试发送
发送失败,异步发送
如果遇到超时,右异步发送了,可以使用去重方法,具体:在数据库建立唯一索引并携带biz_type和biz_id  索引冲突就取消发送
```

```
设计索引
最朴素的方法 WHERE
```

